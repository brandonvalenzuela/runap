// ignore_for_file: avoid_print

import 'dart:async';
import 'dart:math' as math;
import 'package:runap/features/dashboard/domain/entities/dashboard_model.dart';
import 'package:runap/features/map/utils/training_local_storage.dart';
import 'package:runap/utils/http/http_client.dart';

import '../../domain/entities/training_data.dart';

class TrainingService {
  // Singleton pattern
  static final TrainingService _instance = TrainingService._internal();

  factory TrainingService() => _instance;

  TrainingService._internal();

  // Endpoint para obtener los datos del dashboard
  static const String _dashboardEndpoint = 'api/dashboard/obtener-plan?userId=';
  // Endpoint para actualizar una sesi√≥n
  static const String _sessionEndpoint = 'api/sessions';

  // Cache de los datos de entrenamiento
  TrainingData? _cachedTrainingData;
  // Tiempo en que se cachearon los datos
  DateTime? _lastFetchTime;

  // Stream controller para notificar cambios en los datos
  final _trainingDataController = StreamController<TrainingData>.broadcast();
  Stream<TrainingData> get trainingDataStream => _trainingDataController.stream;

  // M√©todo para obtener los datos del dashboard
  Future<TrainingData> getDashboardData(
      {bool forceRefresh = false, int userId = 1}) async {
    print("üí° getDashboardData - Iniciando obtenci√≥n de datos");

    // 1. Verificar cach√© en memoria si no es forzado
    if (!forceRefresh && _cachedTrainingData != null && _lastFetchTime != null) {
      final minutesSinceLastFetch = DateTime.now().difference(_lastFetchTime!).inMinutes;
      if (minutesSinceLastFetch < TrainingLocalStorage.cacheValidityMinutes) {
        print("üí° getDashboardData - Usando cach√© en memoria ($minutesSinceLastFetch minutos)");
        return _modificarSesionesDescansoParaHoy(_cachedTrainingData!);
      }
    }

    // 2. Verificar almacenamiento local si no es forzado
    if (!forceRefresh) {
      final localData = await TrainingLocalStorage.getTrainingData();
      if (localData != null) {
        print("üí° getDashboardData - Usando cach√© del almacenamiento local");
        _cachedTrainingData = TrainingData.fromJson(localData);
        _lastFetchTime = DateTime.now();
        
        // Aplicar modificaciones de datos aleatorios
        _cachedTrainingData = _modificarSesionesDescansoParaHoy(_cachedTrainingData!);
        
        // Notificar a los oyentes
        _trainingDataController.add(_cachedTrainingData!);
        return _cachedTrainingData!;
      }
    }

    // 3. Solo si no hay datos en cach√© o es forzado, obtener de la API
    if (forceRefresh || _cachedTrainingData == null) {
      try {
        print("üí° getDashboardData - Obteniendo datos del servidor");
        final data = await THttpHelper.get('$_dashboardEndpoint$userId');

        // Procesar y guardar los datos
        _cachedTrainingData = TrainingData.fromJson(data);
        _lastFetchTime = DateTime.now();

        // Aplicar modificaciones de datos aleatorios
        _cachedTrainingData = _modificarSesionesDescansoParaHoy(_cachedTrainingData!);

        // Guardar en el almacenamiento local
        await TrainingLocalStorage.saveTrainingData(data);

        // Notificar a los oyentes
        _trainingDataController.add(_cachedTrainingData!);

        return _cachedTrainingData!;
      } catch (e) {
        print("‚ùå Error al obtener datos del servidor: $e");

        // INTENTAR CARGAR CACHE LOCAL COMO FALLBACK ANTES DE PROPAGAR ERROR
        final localDataFallback = await TrainingLocalStorage.getTrainingData();
        if (localDataFallback != null) {
           print("‚ö†Ô∏è Usando CACH√â LOCAL EXPIRADA debido a error de servidor");
           _cachedTrainingData = TrainingData.fromJson(localDataFallback);
           _lastFetchTime = DateTime.now(); // Resetear tiempo para evitar reintentos inmediatos
           _cachedTrainingData = _modificarSesionesDescansoParaHoy(_cachedTrainingData!);
           _trainingDataController.add(_cachedTrainingData!);
           return _cachedTrainingData!;
        }
        
        // Si hay error con la API y TAMPOCO hay datos en cach√© local, propagar el error
        if (_cachedTrainingData == null) { // _cachedTrainingData ser√≠a null si memoria y local fallaron
          throw Exception('Error al obtener datos del entrenamiento y sin cach√© disponible: ${e.toString()}');
        }
        
        // Si llegamos aqu√≠, significa que hubo un error pero s√≠ ten√≠amos cach√© EN MEMORIA (no expirada)
        print("‚ö†Ô∏è Usando cach√© EN MEMORIA debido a error de servidor");
        return _modificarSesionesDescansoParaHoy(_cachedTrainingData!);
      }
    }

    // Si llegamos aqu√≠, significa que tenemos datos en cach√© y no es forzado
    return _modificarSesionesDescansoParaHoy(_cachedTrainingData!);
  }

  // M√©todo para modificar las sesiones de descanso para hoy con datos aleatorios
  TrainingData _modificarSesionesDescansoParaHoy(TrainingData trainingData) {
    final DateTime hoy = DateTime.now();
    final random = math.Random();
    
    print("üîÑ INICIO: Modificando sesiones de descanso para hoy (${hoy.day}/${hoy.month})");
    
    // Variable para contar modificaciones
    int modificacionesRealizadas = 0;
    bool haySessionesHoy = false;
    
    // Primero verificamos si hay alguna sesi√≥n para hoy
    for (var session in trainingData.dashboard.nextWeekSessions) {
      final esHoy = session.sessionDate.year == hoy.year &&
                   session.sessionDate.month == hoy.month &&
                   session.sessionDate.day == hoy.day;
      
      if (esHoy) {
        haySessionesHoy = true;
        print("üìÖ ENCONTRADA: Sesi√≥n para hoy - ${session.workoutName}");
      }
    }
    
    if (!haySessionesHoy) {
      print("‚ö†Ô∏è ALERTA: No hay sesiones programadas para hoy");
      // Si no hay sesiones para hoy, crear una sesi√≥n aleatoria
      _agregarSesionAleatoriaParaHoy(trainingData, hoy);
      return trainingData;
    }
    
    // Comprobar si hay sesiones de descanso para hoy y modificarlas
    for (var i = 0; i < trainingData.dashboard.nextWeekSessions.length; i++) {
      final session = trainingData.dashboard.nextWeekSessions[i];
      
      // Verificar si es una sesi√≥n de hoy 
      final esHoy = session.sessionDate.year == hoy.year &&
                   session.sessionDate.month == hoy.month &&
                   session.sessionDate.day == hoy.day;
                   
      final esDescanso = session.workoutName.toLowerCase().contains('descanso');
      
      if (esHoy) {
        print("üîç REVISANDO: Sesi√≥n de hoy - ${session.workoutName} - ¬øEs descanso? $esDescanso");
        
        if (esDescanso) {
          print("üîÑ MODIFICANDO: Sesi√≥n de descanso para hoy");
          
          // Generar datos aleatorios para esta sesi√≥n
          final tiposEntrenamiento = [
            'Carrera ligera',
            'Entrenamiento cruzado',
            'Caminata recuperativa',
            'Entrenamiento de fuerza suave',
            'Carrera de recuperaci√≥n'
          ];
          
          final distanciasKm = [3, 4, 5, 6, 7];
          final tiemposMin = [20, 25, 30, 35, 40];
          final ritmos = ['6:00', '6:30', '7:00', '7:30', '8:00'];
          
          // Seleccionar valores aleatorios
          final tipoEntrenamiento = tiposEntrenamiento[random.nextInt(tiposEntrenamiento.length)];
          final distanciaKm = distanciasKm[random.nextInt(distanciasKm.length)];
          final tiempoMin = tiemposMin[random.nextInt(tiemposMin.length)];
          final ritmo = ritmos[random.nextInt(ritmos.length)];
          
          // Crear una nueva sesi√≥n con los datos aleatorios
          final nuevaSesion = Session(
            sessionDate: session.sessionDate,
            workoutName: tipoEntrenamiento,
            description: 'Sesi√≥n opcional (d√≠a de descanso): Correr $distanciaKm km en $tiempoMin min a ritmo $ritmo min/km',
            completed: session.completed,
          );
          
          // Reemplazar la sesi√≥n en la lista
          trainingData.dashboard.nextWeekSessions[i] = nuevaSesion;
          modificacionesRealizadas++;
          
          print("‚úÖ √âXITO: Sesi√≥n modificada: ${nuevaSesion.workoutName} - ${nuevaSesion.description}");
        }
      }
    }
    
    print("‚úÖ FIN: Proceso terminado. Sesiones modificadas: $modificacionesRealizadas");
    
    return trainingData;
  }
  
  // Nuevo m√©todo para agregar una sesi√≥n aleatoria para hoy si no hay ninguna
  void _agregarSesionAleatoriaParaHoy(TrainingData trainingData, DateTime hoy) {
    final random = math.Random();
    
    // Generar datos aleatorios
    final tiposEntrenamiento = [
      'Carrera ligera',
      'Entrenamiento cruzado',
      'Caminata recuperativa',
      'Entrenamiento de fuerza suave',
      'Carrera de recuperaci√≥n'
    ];
    
    final distanciasKm = [3, 4, 5, 6, 7];
    final tiemposMin = [20, 25, 30, 35, 40];
    final ritmos = ['6:00', '6:30', '7:00', '7:30', '8:00'];
    
    // Seleccionar valores aleatorios
    final tipoEntrenamiento = tiposEntrenamiento[random.nextInt(tiposEntrenamiento.length)];
    final distanciaKm = distanciasKm[random.nextInt(distanciasKm.length)];
    final tiempoMin = tiemposMin[random.nextInt(tiemposMin.length)];
    final ritmo = ritmos[random.nextInt(ritmos.length)];
    
    // Crear sesi√≥n para hoy con hora actual
    final DateTime fechaHoy = DateTime(hoy.year, hoy.month, hoy.day, 
                                      DateTime.now().hour, DateTime.now().minute);
    
    // Crear una nueva sesi√≥n aleatoria
    final nuevaSesion = Session(
      sessionDate: fechaHoy,
      workoutName: tipoEntrenamiento,
      description: 'Sesi√≥n generada: Correr $distanciaKm km en $tiempoMin min a ritmo $ritmo min/km',
      completed: false,
    );
    
    // Agregar la sesi√≥n a la lista
    trainingData.dashboard.nextWeekSessions.add(nuevaSesion);
    
    print("‚úÖ CREADA: Nueva sesi√≥n para hoy - ${nuevaSesion.workoutName}");
  }

  // M√©todo para marcar una sesi√≥n como completada o no completada
  Future<bool> markSessionAsCompleted(Session session, bool completed,
      {int userId = 1}) async {

    // --- ADDED: Validate sessionId --- 
    if (session.sessionId == null) {
      print("‚õî Error: No se puede marcar la sesi√≥n como completada sin un sessionId.");
      return false;
    }
    // --- END ADDED --- 

    try {
      // Verificar si la sesi√≥n ya pas√≥ y asegurarnos de que se marque como no completada
      final now = DateTime.now();
      final sessionDate = session.sessionDate;
      if (sessionDate.isBefore(now) && completed) {
        // Si la sesi√≥n ya pas√≥, no permitir marcarla como completada
        print(
            "üîí No se puede marcar una sesi√≥n pasada como completada. Se marcar√° como no completada.");
        completed = false; // Forzar a no completado si ya pas√≥
      }

      print("üí° Enviando solicitud para marcar sesi√≥n ID: ${session.sessionId} como $completed");

      // Crear el cuerpo de la solicitud
      final Map<String, dynamic> body = {
        // Remove sessionId from body if it's part of the URL path
        // 'sessionId': session.sessionId,
        'completed': completed,
      };

      // --- UPDATED: Use sessionId in the endpoint URL --- 
      // Realizar la llamada PUT a la API (asumiendo que el ID va en la URL)
      await THttpHelper.put('$_sessionEndpoint/${session.sessionId}?userId=$userId', body);
      // --- END UPDATED --- 

      // Actualizar el estado local en el cach√©
      if (_cachedTrainingData != null) {
        final index = _cachedTrainingData!.dashboard.nextWeekSessions
            .indexWhere((s) => s.sessionId == session.sessionId);
        if (index != -1) {
          _cachedTrainingData!.dashboard.nextWeekSessions[index].completed = completed;
          // Actualizar las estad√≠sticas generales del dashboard
          _cachedTrainingData!.dashboard.updateStats();
          // Notificar a los oyentes
          _trainingDataController.add(_cachedTrainingData!); 
           // Opcional: Guardar cambios en local storage? Por ahora no para simplicidad
           // await TrainingLocalStorage.saveTrainingData(_cachedTrainingData!.toJson()); 
           print("‚úÖ Sesi√≥n ID: ${session.sessionId} marcada localmente como $completed");
        } else {
          print("‚ö†Ô∏è No se encontr√≥ la sesi√≥n ID: ${session.sessionId} en el cach√© local despu√©s de la llamada API.");
        }
      }

      return true;
    } catch (e) {
      print("‚õî ‚ùå Error al marcar sesi√≥n como completada en el servicio: $e");
      return false;
    }
  }

  // M√©todo para limpiar recursos al cerrar la aplicaci√≥n
  void dispose() {
    _trainingDataController.close();
  }

  // M√©todo p√∫blico para forzar la generaci√≥n de datos aleatorios para hoy
  Future<TrainingData?> generarDatosAleatoriosParaHoy() async {
    print("üöÄ TrainingService - Generando datos aleatorios para hoy");
    
    if (_cachedTrainingData == null) {
      print("‚ùå No hay datos en cach√© para modificar");
      return null;
    }
    
    // Hacer una copia profunda para no afectar los datos originales
    // hasta que estemos seguros de los cambios
    TrainingData datosModificados = TrainingData(
      dashboard: Dashboard(
        raceType: _cachedTrainingData!.dashboard.raceType,
        targetPace: _cachedTrainingData!.dashboard.targetPace,
        goalTime: _cachedTrainingData!.dashboard.goalTime,
        weeksToRace: _cachedTrainingData!.dashboard.weeksToRace,
        totalSessions: _cachedTrainingData!.dashboard.totalSessions,
        completedSessions: _cachedTrainingData!.dashboard.completedSessions,
        completionRate: _cachedTrainingData!.dashboard.completionRate,
        nextWeekSessions: List.from(_cachedTrainingData!.dashboard.nextWeekSessions),
      ),
    );
    
    // Aplicar la modificaci√≥n
    final DateTime hoy = DateTime.now();
    
    // Verificar si hay sesiones para hoy
    bool haySessionesHoy = false;
    for (var session in datosModificados.dashboard.nextWeekSessions) {
      final esHoy = session.sessionDate.year == hoy.year &&
                   session.sessionDate.month == hoy.month &&
                   session.sessionDate.day == hoy.day;
      
      if (esHoy) {
        haySessionesHoy = true;
        break;
      }
    }
    
    if (!haySessionesHoy) {
      // Si no hay sesiones para hoy, crear una
      print("‚ö†Ô∏è No hay sesiones para hoy, creando una nueva...");
      _agregarSesionAleatoriaParaHoy(datosModificados, hoy);
    } else {
      // Si hay sesiones, intentar modificar las de descanso
      print("‚úÖ Hay sesiones para hoy, modificando seg√∫n sea necesario...");
      bool hayDescansoHoy = false;
      
      // Verificar si hay sesiones de descanso para hoy
      for (var session in datosModificados.dashboard.nextWeekSessions) {
        final esHoy = session.sessionDate.year == hoy.year &&
                     session.sessionDate.month == hoy.month &&
                     session.sessionDate.day == hoy.day;
        
        if (esHoy && session.workoutName.toLowerCase().contains('descanso')) {
          hayDescansoHoy = true;
          break;
        }
      }
      
      if (hayDescansoHoy) {
        // Si hay sesiones de descanso, modificarlas
        print("üîÑ Hay sesiones de descanso para hoy, cambi√°ndolas...");
        datosModificados = _modificarSesionesDescansoParaHoy(datosModificados);
      } else {
        // Si no hay sesiones de descanso, no hacemos nada
        print("üí° Las sesiones para hoy no son de descanso, no es necesario modificarlas");
      }
    }
    
    // Actualizar en cach√©
    _cachedTrainingData = datosModificados;
    _lastFetchTime = DateTime.now();
    
    // Notificar a los listeners
    _trainingDataController.add(datosModificados);
    
    print("‚úÖ TrainingService - Datos aleatorios generados y notificados");
    
    return datosModificados;
  }

  // Sincronizar datos pendientes con el servidor
  Future<void> syncPendingChanges(int userId) async {
    // Implementar l√≥gica para sincronizar cambios pendientes
    // Por ejemplo, verificar sesiones marcadas como completadas localmente
    // pero que a√∫n no se han enviado al servidor
  }

  // M√©todo para actualizar una sesi√≥n
  Future<void> updateSession(Session session) async {
    try {
      final response = await THttpHelper.put(
        '$_sessionEndpoint/${session.sessionDate.millisecondsSinceEpoch}',
        session.toJson(),
      );

      if (response == null) {
        throw Exception('Error al actualizar la sesi√≥n');
      }
    } catch (e) {
      throw Exception('Error al actualizar la sesi√≥n: $e');
    }
  }

  // M√©todo para guardar los datos en el almacenamiento local
  Future<void> saveLocalDashboardData(TrainingData data) async {
    try {
      await TrainingLocalStorage.saveTrainingData(data.toJson());
    } catch (e) {
      throw Exception('Error al guardar los datos localmente: $e');
    }
  }

  // M√©todo para obtener los datos del almacenamiento local
  Future<TrainingData?> getLocalDashboardData() async {
    try {
      final jsonData = await TrainingLocalStorage.getTrainingData();
      if (jsonData == null) return null;
      return TrainingData.fromJson(jsonData);
    } catch (e) {
      throw Exception('Error al obtener los datos locales: $e');
    }
  }
}
